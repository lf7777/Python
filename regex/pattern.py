import re

line = 'abAec4_\n_'


#定义模式

pattern = '\W*'

#通过 模式 及 内容 找到结果

res = re.search(pattern,line,re.S)

print(res)

#print(res.group())

#print(len(res.group(2)))


#           作用

#贪婪匹配   匹配尽量多的内容

#非贪婪匹配 匹配尽量少的内容

# *         匹配上一个RE的0个或多个（贪婪的）重复。
            #贪婪意味着它将匹配尽可能多的重复

# ^         以它后面的字符作为开头

# .         能够表示除了换行符(\n)的 任何字符(可以1个.多少个.都行,\c\r啥都行)

# . 匹配\n  匹配 \n 在 函数里添加 re.S 示 例 : search(pattern,line,re.S)

#\d         匹配数字 (一个 \d 匹配 一个数字)

# * 贪婪   *能匹配到 *前面的内容重复的 任意数量 示 例 : \d* 有多少匹配多少数字

# ? 非贪婪  如果前面跟的是 表示数量的限定词,表示 非贪婪
            #示 例 : \d*?ab 匹配所有数字后,到 ab 结束

# ? 0-1此   如果前面跟的是 代表一个字符的,则表示 匹配 0次到1次.
             
# $         按照从头到位找的顺序,找到 写在$前面的.示 例 : 3$ 表以 3 结尾       

#()         #<1> 只要()中的内容,两边的都不要

            #<2>以 ( 开头了 就是一个组,查找哪个组的内容,就在group()里写对应参数
            #默认空为全部,不找个别组的.也就是参数为0.

#{}         .{} = .* and .{}? = .*?
            #和 .* 区别 可以指定个数的 .
            #比如 .{10} 就是 .{0,10}, .乘以10个 .{0,8} 则要8个
            #.{0,} = .* 无穷个

# +         用法:.+h = .*h 但 .+?h 表达 在取到下个h之前 不会取空的
            #匹配前面RE的1个或多个（贪婪的）重复。

# | 或      用法: (sss)|(aaa) 优先匹配前一个
            #!!!加上group的用法:(sss)括号是参数0,(aaa)是参数2
            #这是傻逼用法,因为是或

# []        限制版的 . 对.进行限制,[a-z],[0-9],[a-zA-Z0-9]
            #中括号,当前位置的字符 可以是哪些字符(顺序无所谓)
            #[]表 可以取走 1 个
            #[]*表 可以取走多个,文本里就都已取到

#[^] 非     [^a-zA-Z] 指内容为[^]的不取

# \s        匹配任何空白字符,包括空格,制表符,换页符等等,等价于[\f\n\r\t\v]
            #但group()之后,就把换行符号 转为 真实换行了.

# \S        匹配任何 与 \s 完全相反的,字母啊数字啊等等都可以.

# \w        用来 匹配 字符和数字 等价于 [A-Za-z0-9]

# \W        用来匹配 字母和数字 之外其他的数据

# \d        数字 等价于[0-9]
