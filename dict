dict:字典,全称dictionary

定 义 字 典 :

注 意 : 字典的 键 ,必须是不可改变的类型

<1>d = {}

<2>d = dict(形参 = 值,形参 = 值)
    形参不能是数字,字符串类型的数字 也不行.

<3>转换为 字典 :
    变量 = dict(符合条件的嵌套 列表 元祖)
        a = [[1,2],[2,3],[3,4]]
        c = dict(a)

<4>通过 zip 将两个 列表,元祖 打包.
dict(zip(迭代器,迭代器))

    a = [1,2,3]
    b = [4,5,6]
    dict(zip(a,b))
        return {1:4,2:5,3:6}
        if 长度 不相等 ,得到最小长度的.

<5>fromkeys()
    list = [1,2,3]
        result = {}.fromkeys(list,容器数据)
        详见 八.

一. 增 :

<1>d['e'] = 5  
   d[111] = 5
    为字典 添加 新的 数据.

<2>update() : 函数式 赋值 :
添加 且 更新 . 更新字典
    字典.update(c=2)
    字典.update('c':2)

    字典.update({22:33}) 传入字典,必须 : 号 隔开.
    字典.update([(1,2),(2,3)]) 
    错误 : 字典.update((1,2),(2,3)) 只能有一个参数.

    键是字符串,不能是数字.也不能是字符串类型的数字.
        因为是 关键字参数,涉及到变量,变量不能以数字开头.
    键是字符串,不用加引号.而值是字符串 需要加引号.

    (1)单个值 :
    先声明 字典 ! 
        d.update(b=2)  
        增加键值对进入字典,注意是等号,更新原字典.

    (2)多个值
    先声明 字典 !  
        d.update(c=3, d=4)  
        可以同时增加多个键值对,更新原字典.

    (3)d.update({'f': 6, 'g': 7})   
        用新字典更新旧字典.没有则新增,有则修改值 

    (4)update() 想传数字 :
        字典.update({22:33})
 
<3>setdefault()
添加不修改 . 添加键值对 

    字典.setdefault(5,6)
    字典.setdefault('a',6)
    字典.setdefault(10,'a')
    错误 : 字典.setdefault([1,2],[2,3]) 只能有两个参数,但不能是列表.

    特 点 :  
    (1)有 就无法覆盖,无 则创建.
    (2)只能 有两个参数,故一次 只能 传一个 键值对. 
    (3)逗号 隔开
    (4)键 可以是数字
        因为 是传参数,所以可以是数字.
    (5)键 值 是字符串时,必须加引号.

 
<3>覆 盖 : 小心 使用 :
    d = {'a': 1}  
    将字典赋值个对象
        重复使用 则覆盖原有.


二. 删 :

<1>del d['Bob']
    原生删除

<2>d.pop(key) 
    只能删除键,括号里必须有键名.

<3>d.popitem()
    随机删除一个



三. 改 :

<1>d[key] = 90
    原生修改

update() 的第一个参数 不能为数字,字符串类型数字同样不可以.

<2>d.update(c=5,b=6) 
    第一个参数 不能带引号,不能为数字,字符型数字.
    函数式更新修改

<3>d.update({'c':5,'b':6})
    函数式更新修改
    


四. 查 :


<1>d['Adma'] 

    (1)存在 : 直接查找键,返回值

    (2)不存在 : 程序报错结束

<2>d.get('Adam') get方法 : 只适用字典 

    (1)存在 : 返回该键的值,

    (2)不存在: 返回None
        或 设置 get('Adam',容器数据)
            返回 容器数据

<3>'Adam' in d 
    可以查找键在dick里面存在否,存在True,不存在False

<5>d.keys()
    获取字典的所有键,结果为键,可以使用list(d.keys()),转换为列表.

<6>d.values()
    获取字典的所有值:d.values()  结果为值.也可以使用list

<7>d.items() 
    结果为将所有键值对括起来,获取字典所有键值对,也可获取长度len(d.items()). 
    也可以转换为列表list(d.items())

<8>枚举 :
    enumerate(d)  用for...in遍历枚举字典的键,结果为
        (0,'name')  (1,'age')

    也可以enumerate(d.items()).  等于枚举所有键值对.结果为
        (0,'name','Bob')



五. 字典 遍历 :

<1>遍历 键 :
    for i in dict:
        print(i)

<2>遍历 值 :
    for i in dict.values()
        print(i)

<3>遍历 键 值 :
    (1)for i in dict:
           print(i,dict[i])

    (2)for i,k in dict.items()
        print(i,k)


<4>分别将字典 拆成 只存键 和 只存值的 的步骤 :

(1)d = {'a':1,'b':2,'c':3}
(2)l = d.items()
    return [('a',1),('b',2),('c',3)]
(3)z = zip(*l)  拆包 : 一一对应.
(4)new = list(z) 拆包之后,立即用变量 接收.
(5)key = list(new[0])
(6)values = list(new[1])



六. 字 典 推 导 式 :

<1>基本推导式 :
    变量 = {变量1:变量2 for 变量1,变量2 in 字典.items()}
        return 字典

<2>带条件的 字典推导式 :
    变量 = {变量1:变量2 for 变量1,变量2 in 字典.items() if 变量1 != 某键或某值}
        return 排除掉 某键值对 的 字典.

<3>多循环的 字典推导式 :
    变量 = {变量1:(+...其他运算也可以)变量b for 变量1,变量2 in 字典1.items() 
                                            for 变量a,变量b in 字典2.items()
           }

    结果变量 : 字典推导式最左侧的 语句块,只能是一个语句块,不能用 逗号隔开.

测试:x = {i+l for i,k in {'a':'A','b':'B'}.items() for l,n in {'c':'C','d':'D'}.items()}

<4>带判断的 多循环 列表推导式 :
    每个 for...in 语句结束后面,都可以 各自添加 各自的 if 语句. 


<5>字符串 格式化 字典
   people = {'good':'小明','girl':小红} 
   str = '我的好朋友是%(good)s,我的女朋友是%(gril)s'
   print(str%people)



七. 字典 函数:

值 是字符串类型 : 按照ascii编码的大小排:比如 a > A >0

<1>max() 默认比较 键
    max(dict.values())

<2>min() 默认比较 键
    min(dict.values())

<3>len()

<4>dict()

<5>dict.copy()

<6>items()
    语法: dict.items(). 不能写在()里面
    以列表返回可遍历的(键, 值) 元组数组 : [('mike',20)('bob',30)]
    并不会修改原值,用新变量指向.

<7>通过 zip 将两个 列表,元祖 打包.
dict(zip(迭代器,迭代器))

    a = [1,2,3]
    b = [4,5,6]
    dict(zip(a,b))
        return {1:4,2:5,3:6}
        if 长度 不相等 ,得到最小长度的.


八. 字典 专有函数 :

<1>clear()
清空字典
    friends={'name':'小明'}
        friends.clear()
            变为一个空字典
    id(friends) 字典的 id 是不变的

<2>copy()
复制字典
    friends={'name':'小明'}
        x = friends.copy()
    id(friends) id(x) id 是不相同的

<3>fromkeys()
造一个字典 值都相同的 字典

    更新 已有字典 的内容.
    字典.fromkeys(容器数据作为键,容器数据作为值)
        字典的 键 是 容器的每个元素,重复则后面覆盖前面.
        字典的 值 是 整个 第二个容器数据
            if 值 传了 列表作为参数,则 整个容器 都是一个键的值.

<4>keys()
获取 键 组成 新容器
    字典.keys()


<5>values()
获取 值 组成 新容器
    字典.values()


<6>items()
获取 键值对 组成 嵌套新容器
    字典.items()
    items()后 并不是真正列表,需要list()


<7>pop()
字典.pop(键)
    return 值

    字典.pop(键,容器数据)
        有则 直接删,返回 值
        无则 返回 第二个参数.此种方法 同get()相同.

<8>popitem()
    删除最后一个 键值对,删除的 可用变量接收. 


<10>setdefault()
添加键值对


<11>update()


<12>get()
返回 None 或返回 指定参数

d.get('Adam') get方法 : 只适用字典

    (1)存在 : 返回该键的值,

    (2)不存在: 返回None
        或 设置 get('Adam',容器数据)
            返回 容器数据




九. 补 充 :

<1>序 列 操 作 :
    (1)因为 字典数据类型 没有索引,所以无法使用切片,索引操作.

    (2)字典类型没有 乘法 与 加法运算.

    (3)成员检测:
        in 
        not in 

<2>len(dict[])
    d = {'Michael':85,
        'Bob':75,
        85:'Tracy'}
    len(d[85]) : 获取 85 的值 的长度.  

<3>注意:把字典变为一对对的可操作的元祖,需要先dict.items(),如果需要遍历要传两个参数.

<4>元素可以字符对字符,字符对数字,数字对数字,数字对字符等.
    不可以通过值 找 键.

<5>需要牢记的第一条就是dict的key必须是不可变对象。

    这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。
要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：


<6>无 count()
    只有 有序容器 有.
