一. 概 念 :


    <1> 一个 类 或 对象 获取另一个类的成员 属性 方法的操作.(并非所有成员)

    <2> 被其他类继承的类 叫 父类 基类 超类.
    
    <2> 继承 其他类的类 叫 子类 派生类.


    单 继 承 : (生物角度理解)

        概 念 : 线性继承.从小到大的继承,从上继承.

        优 劣 : 便于管理类的关系.继承关系命了.因为是线性的.

                基本 无劣势.

        人类 -> 哺乳类动物 -> 动物 -> 生物 -> ...


    多 继 承 : (社会角度理解)

        概 念 : 发散继承.一个类 具有多个父类.

        优 劣 : 优势:减少代码量.

                劣势:不便于查找,过于错综复杂容易乱.

        从舞蹈老师 继承 跳舞.
        从体育老师 继承 运动.
        从企业老板 继承 管理.

        我 会 : 跳舞 运动 管理.


    多 继 承 的 菱形继承 或者 钻石继承  BUG : (具体内容参见 第四标题)


二. 特 征 : 


    <1> 在不指定父类的情况下,所有的类均继承自object类(系统提供的)

    <2> 私有化的成员, 子 类  同样不能访问,格式 变量名前加 __

    <3> 子类 同 父类的 实例化对象一样,不会复制一份,会向父类 索要.

    <4> 子类 自有的 ,则不会 向父类 索要.

    <5> 子类 可以根据 自己的 需求 添加子集独有的成员 进行操作.
   
    <6> 重 载 : 对成员方法重新定义.

            原 理 : 对象找 子类要,子类中有,就不再向上找.

            (1) 属性重载 : 子类中 以相同的 变量名 重写一份.

            (2) 方法重载 : 子类中 以相同的 变量名 重写一份.

    <7> 在子类中 调用父类 的属性方法.

            (1) super().父类属性或方法

            super()类原理:通过继承关系创建MRO列表.

                    条件 : 必须是带有 self 的对象方法才可以使用.

                原 理 : 利用 super()类查找 MRO列表的 上一个类. 

                        new = super() new.方法() 等同于 :

                        super().方法
                      
                        所以理论上讲通过super()类调用方法 是super()类示例化调用.
                
            (2) 父类.方法(self) 父类.属性

                    条件 : 有无 self 都可以,有就带上参数 self


    
三. 格 式 : 

    <1> 继 承 格 式 :

        class 父类:
    
            属性
    
            方法

        class 子类(父类):
        
            pass


    <2> 私 有 化 格 式 : 在属性 或 方法 变量名前 加 __
        

          
四.多 继 承 : 


    <1> 格 式 : class(父类1,父类2,父类3)


    <2> 多 继 承 的  菱 形 BUG:
    
            某个方法在继承中被多次调用. 

            如果该方法具有为唯一或者计时类似的特性,则无法使用.

            <3> BUG
                                    A类

                            B类             C类

                                    D类

                    B C 继承 A
                    D   继承 B C
                    B C 的方法 都调用了 A的方法
                    D   的方法同时调用 B C 中调用了 A的方法

                    结 果 : D 通过 B C 调用了 两次 A 的方法

                            产生了逻辑的错误.
                    

            <4> 解决方案 : 
                    
                MRO(Method Relationship Order)列表 和 super()类 : 

                MRO列表 : 生成采用了C3算法完成.

                C3算法原理 :
                    
                在 列 表 中 :

                    1.子类 永远在父类的前面.

                    2.同一等级的类,按照子类参数的继承顺序摆放.(逗号隔开)

                            列 表 : 假设A类参数 B类在前 则 :

                                    A类

                                    B类,C类

                                    D类

                解决方案的原理 : 

                通过super()将继承变为线性的列表,顺序根据参数顺序,原本菱形的中间

                两极,在列表中变为了上下级,通过super()不断向上查找,最终只找到了

                一个最上级类.



五. 多 继 承 的 应 用(mixin设计模式) :


<1> 概 念 : mixin : 混入

    优 点 :
   
        (1) mixin设计模式可以在不对类的内容的修改前提下,扩展类的功能(添加父类)

        (2) 更加方便的组织和维护不同的组建.

        (3) 可以根据开发需要任意调增功能.

        (4) 可以避免产生更多的类.

    缺 点 :

        (1) 受继承关系的限制,推荐只有两层的继承使用.


    推 荐 : 父类和子类 只有两层,父类之间没有关系.

            子类需要什么功能,给所有子类 添加新 父类的 参数.

            要什么 加 什么.
